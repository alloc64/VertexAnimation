function myGetCorrespTVert iMeshVert iFace CurMesh =(	MeshFace = getFace CurMesh iFace  TVFace = getTVFace CurMesh iFace  if(TVFace == undefined) then  (     print "error: mesh "+ CurMesh.name +" has no TVfaces!"    return 0  )	  if MeshFace.x == iMeshVert then		return TVFace.x	else if MeshFace.y == iMeshVert then 		return TVFace.y	else 		return TVFace.z)function exportXMAfile entHealth entFramerate =(                                                                             		strFileName = getSaveFileName caption:"Save Dynamic XMAPerVertex file" types:"XMAPerVertex file *.xma|*.xma"		if strFileName == undefined then return "error: XMA export aborted!"		file = fopen strFileName "wb"		if file == undefined then  return "error: could not create file!"    if rootnode.children.count == 0 then return "error: 0 objects selected!"		                                                                                	WriteString file "#XMA FileFormat By Jatro 8D\n#XMA is an fileformat for XMEngine (c) Jatro!"    WriteString file "LXMA24"             arrMeshes = #()         	arrNames = #()  	arrObjects = #()  	arrEntities = #()                                                              format "ok: writing % dynamic entities!\n" $objects.count    WriteShort file $objects.count            startFrame = animationRange.start    endFrame   = animationRange.end        num_frames = (endFrame - startFrame)+1;    if (num_frames == 2) do num_frames  = 1                   if (num_frames == 1) do endFrame = startFrame                                WriteShort file num_frames    WriteShort file entFramerate -- frameRate je sice sexy ale je uplne napicu ;)         WriteShort file entHealth               for i = 1 to $objects.count do    (                  if($objects[i] == undefined) then continue;       mesh = snapshot $objects[i]                                                                                                     if mesh == undefined or not isKindOf mesh Editable_Mesh then        (           print ("error: " + $objects[i].name + " isn't convertable to editable mesh!")           continue;       )else(                                 		   if isGroupMember $objects[i] then setGroupMember $objects[i] false           print ("ok: generating geometry data: " + $objects[i].name + ", " + (i-1) as string)       )             		     if mesh != undefined then delete mesh              for f = startFrame to endFrame do       (         at time f         (              CurMesh = snapshotAsMesh $objects[i]                        struct SFaceGroup (iSmoothGroup, arrFaces, iTVert)          		for iCurVert = 1 to CurMesh.verts.count do          		(                    			arrFaceGroups = #()          			arrVertFaces = meshop.getFacesUsingVert CurMesh iCurVert          			for iAktFace = 1 to arrVertFaces.count do          			(          				if arrVertFaces[iAktFace] then           				(          					global FaceGroup = SFaceGroup iSmoothGroup:(getFaceSmoothGroup CurMesh iAktFace) arrFaces:#(iAktFace) iTVert:-1          					append arrFaceGroups FaceGroup          				)          			)          			if arrFaceGroups.count > 0 then          			(          				do          				(          					bChanged = false          					for iAktFaceGroup = 1 to arrFaceGroups.count do          					(          						iCompFaceGroup = iAktFaceGroup+1          						while iCompFaceGroup <= arrFaceGroups.count do          						(          							if ((bit.and arrFaceGroups[iAktFaceGroup].iSmoothGroup arrFaceGroups[iCompFaceGroup].iSmoothGroup != 0)) then          							(          								iNewSmoothGroup = bit.or arrFaceGroups[iAktFaceGroup].iSmoothGroup arrFaceGroups[iCompFaceGroup].iSmoothGroup          								join arrFaceGroups[iAktFaceGroup].arrFaces arrFaceGroups[iCompFaceGroup].arrFaces          								arrFaceGroups[iAktFaceGroup].iSmoothGroup = iNewSmoothGroup          								deleteItem arrFaceGroups iCompFaceGroup          								bChanged = true          							)          							else          								iCompFaceGroup += 1          						)          					)          				)          				while bChanged          				for iAktGroup = 2 to arrFaceGroups.count do          				(          					iNewVertIndex = setNumVerts CurMesh (CurMesh.numverts+1) true          					setVert CurMesh iNewVertIndex CurMesh.verts[iCurVert].pos          					-- add texture vertex as well           					for iAktFace in arrFaceGroups[iAktGroup].arrFaces do          					(          						AktFace = getFace CurMesh iAktFace          						if AktFace.x == iCurVert then           							AktFace.x = iNewVertIndex          						else if AktFace.y == iCurVert then           							AktFace.y = iNewVertIndex          						else           							AktFace.z = iNewVertIndex          						setFace CurMesh iAktFace AktFace          					)								          				)          			)          			else          				print ("error: isolated vertex found: " + iCurVert as string)          		)          		update CurMesh                    		arrNormals = #()          		for iAktVert = 1 to CurMesh.numverts do          			append arrNormals (getNormal CurMesh iAktVert)          			arrTVerts = #()                    			for iCurVert = 1 to CurMesh.verts.count do          			(          				arrFaceGroups = #()          				arrVertFaces = meshop.getFacesUsingVert CurMesh iCurVert          				for iAktFace = 1 to arrVertFaces.count do          				(          					if arrVertFaces[iAktFace] then           					(          						-- first we store one FaceGroup for every face of the vertex          						global FaceGroup = SFaceGroup iSmoothGroup:-1 arrFaces:#(iAktFace) iTVert:(myGetCorrespTVert iCurVert iAktFace CurMesh)          						append arrFaceGroups FaceGroup          					)          				)          				if arrFaceGroups.count > 0 then          				(          					for iAktFaceGroup = 1 to arrFaceGroups.count do          					(          						iCompFaceGroup = iAktFaceGroup+1          						while iCompFaceGroup <= arrFaceGroups.count do          						(          							if ((arrFaceGroups[iAktFaceGroup].iTVert == arrFaceGroups[iCompFaceGroup].iTVert) or           								((getTVert CurMesh (arrFaceGroups[iAktFaceGroup].iTVert)) == (getTVert CurMesh (arrFaceGroups[iCompFaceGroup].iTVert)) ) ) then          							(          								join arrFaceGroups[iAktFaceGroup].arrFaces arrFaceGroups[iCompFaceGroup].arrFaces          								deleteItem arrFaceGroups iCompFaceGroup          							)          							else          								iCompFaceGroup += 1          						)          					)                					arrTVerts[iCurVert] = getTVert CurMesh (arrFaceGroups[1].iTVert)					        					for iAktGroup = 2 to arrFaceGroups.count do        					(        						iNewVertIndex = setNumVerts CurMesh (CurMesh.numverts+1) true        						setVert CurMesh iNewVertIndex CurMesh.verts[iCurVert].pos        						-- add texture vertex as well         						arrTVerts[iNewVertIndex] = getTVert CurMesh arrFaceGroups[iAktGroup].iTVert        						arrNormals[iNewVertIndex] = arrNormals[iCurVert]        						for iAktFace in arrFaceGroups[iAktGroup].arrFaces do        						(        							AktFace = getFace CurMesh iAktFace        							if AktFace.x == iCurVert then         								AktFace.x = iNewVertIndex        							else if AktFace.y == iCurVert then         								AktFace.y = iNewVertIndex        							else         								AktFace.z = iNewVertIndex        							setFace CurMesh iAktFace AktFace        						)								        					)        				)        			)              if(f == 0) then              (                  print("ok: exporting faces and tcoords!")                  WriteShort file ($objects[i].name.count+1)                   WriteString file $objects[i].name               	                 		WriteShort file CurMesh.numverts                   WriteShort file CurMesh.numfaces               	  for iCurVert = 1 to CurMesh.numverts do              		(              			pntTVert = arrTVerts[iCurVert]                       WriteFloat file (pntTVert.x)                    WriteFloat file ((pntTVert.y*-1.0+1.0))               		)                      for iCurFace = 1 to CurMesh.numfaces do              		(              			face = getFace CurMesh iCurFace              			WriteLong file (face.x as integer - 1)                     WriteLong file (face.z as integer - 1)                     WriteLong file (face.y as integer - 1)              		)                )                        	  for iCurVert = 1 to CurMesh.numverts do          		(          			vertex = CurMesh.verts[iCurVert]          			WriteFloat file vertex.pos.x                WriteFloat file vertex.pos.y                WriteFloat file vertex.pos.z          		)                       		 )                                                        )                                                                      if  $objects[i].material != undefined or $objects[i].material == Standard then      	(                        		if $objects[i].material.diffuseMap != undefined then (      			compPath = $objects[i].material.diffuseMap.filename as string      			strTextureFileExploded = filterString compPath "\\."  			    texpath = "textures/" + strTextureFileExploded[strTextureFileExploded.count - 2] + "/" +strTextureFileExploded[strTextureFileExploded.count - 1] + "." + strTextureFileExploded[strTextureFileExploded.count]                       WriteShort file (texpath.count+1)             WriteString file texpath        				WriteShort file 2      		) else (             		  texpath = "undefined.dds"            WriteShort file (texpath.count+1)             WriteString file texpath        				WriteShort file 2      		)		            	) else (      		  texpath = "undefined.dds"            WriteShort file (texpath.count+1)             WriteString file texpath      				WriteShort file 2       	)     )          print ("ok: exported!");)                   utility max2xmlevel "Export *.XMAPerVertex file" (   group "Entity properties"  (  	spinner entHealth "Entity health: "  type:#integer range:[0,1000,100]  	spinner entFramerate "Anim rate: "  type:#integer range:[0,1000,30]  )  group "File export"  (  	button export "Export XMAPerVertex File..."  )  		on export pressed do	(                 exportXMAfile entHealth.value entFramerate.value           )	)  